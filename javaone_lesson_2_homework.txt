/*
 * 1 Задать целочисленный массив, состоящий из элементов 0 и 1. Например: [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 ]. Написать метод,
 * заменяющий в принятом массиве 0 на 1, 1 на 0;
*/

int[] arr = {1, 1, 0, 0, 1, 0, 1, 1, 0, 0};

public static int[] changeOneZero(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == 0) {
            arr[i] = 1;
        } else {
            arr[i] = 0;
        }
    }
    return arr;
}



/*
 * 2 Задать пустой целочисленный массив размером 8. Написать метод, который помощью цикла заполнит его значениями 1 4 7 10 13 16
 * 19 22;
*/

int[] arr = new int[8];

public static int[] fillArr(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        arr[i] = 3 * i + 1;
    }
    return arr;
}



/*
 * 3 Задать массив [ 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 ], написать метод, принимающий на вход массив и умножающий числа меньше
 * 6 на 2;
*/

int[] arr = {1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1};

public static int[] multby2(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] < 6) {
            arr[i] *=2;
        }
    }
    return arr;
}



/*
 * 4 Задать одномерный массив. Написать методы поиска в нём минимального и максимального элемента;
*/

int[] arr = {1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1};    // взял для примера из задачи 3

public static int findMin(int[] arr) {
    int temp;                                    // temp - переменная для временного хранения значения элемента массива
    for (int i = 0; i < arr.length - 1; i++) {
        if (arr[i] < arr[i+1]) {
            temp = arr[i+1];
            arr[i+1] = arr[i];
            arr[i] = temp;
        }
    }
    return arr[arr.length-1];
}

public static int findMax(int[] arr) {
    int temp;
    for (int i = 0; i < arr.length - 1; i++) {
        if (arr[i] > arr[i+1]) {
            temp = arr[i+1];
            arr[i+1] = arr[i];
            arr[i] = temp;
        }
    }
    return arr[arr.length-1];
}



/*
 * 5 * Создать квадратный целочисленный массив (количество строк и столбцов одинаковое), заполнить его диагональные элементы
 * единицами, используя цикл(ы);
*/

int[][] arr = new int[5][5];

public static int[][] fillDiagQuadrat(int[][] arr) {
    for (int i = 0; i < arr.length; i++) {
        arr[i][i] = 1;
        arr[i][arr.length-1-i] = 1;
    }
    return arr;
}



/*
 * 6 ** Написать метод, в который передается не пустой одномерный целочисленный массив, метод должен вернуть true если в массиве
 * есть место, в котором сумма левой и правой части массива равны. Примеры: checkBalance([1, 1, 1, || 2, 1]) → true, checkBalance
 * ([2, 1, 1, 2, 1]) → false, checkBalance ([10, || 1, 2, 3, 4]) → true. Абстрактная граница показана символами ||, эти символы в
 * массив не входят.
*/

public static boolean checkBalance(int[] arr) {
    float sumTotal = 0, sum = 0;

    for (int i = 0; i < arr.length; i++) {    // подсчет суммы всех элементов массива
        sumTotal += arr[i];
    }

    for (int i = 0; i < arr.length - 1; i++) {
        sum += arr[i];
        if (sum == sumTotal / 2) {
            return true;
        }
    }
    return false;
}



/*
7 *** Написать метод, которому на вход подаётся одномерный массив и число n (может быть положительным, или отрицательным), при
* этом метод должен циклически сместить все элементы массива на n позиций.
*/

public static int[] shiftArray(int[] arr, int n) {
    int[] result = new int[arr.length];
    int shift = n % arr.length;

    if (shift < 0) {          // превращение отрицательного сдвига в положительный
        shift += arr.length;
    }

    for (int i = 0; i < arr.length; i++) {
        if (i + shift < arr.length) {
            result[i+shift] = arr[i];
        } else {
            result[i+shift-arr.length] = arr[i];
        }
    }

    for (int i = 0; i < arr.length; i++) {    // перезапись смещенных элементов в исходный массив
            arr[i] = result[i];
        }
    
    return arr;
}



/*
 * 8 **** Не пользоваться вспомогательным массивом при решении задачи 7.
*/

public static int[] shiftArray(int[] arr, int n) {
    int shift = n % arr.length;
    int temp1, temp2;

    if (shift < 0) {
        shift += arr.length;
    }

    for (int i = 1; i <= shift; i++) {    // цикл количества шагов сдвига в положительную сторону
        temp1 = arr[0];

        for (int j = 0; j < arr.length - 1; j++) {    // цикл сдвига всех элементов массива на 1 позицию в положительную сторону
            temp2 = arr[j+1];
            arr[j+1] = temp1;
            temp1 = temp2;
        }
        arr[0] = temp1;
    }

    return arr;
}












